#!/bin/sh
# Enhanced ATC CLI with FCC Unlock support
# Version: 1.2.1

PROG_NAME="enhanced-atc-cli"
VERSION="1.2.1"

# Configurable paths via environment variables (M2 fix)
DEFAULT_DEVICE="${ATC_DEFAULT_DEVICE:-/dev/ttyUSB3}"

usage() {
    cat << EOF
$PROG_NAME v$VERSION - Enhanced ATC with FCC Unlock (Fibocom FM350-GL)

USAGE: $PROG_NAME [OPTIONS] COMMAND

COMMANDS:
    status          Show connection status
    fcc-status      Check FCC lock status
    fcc-unlock      Perform FCC unlock
    fw-info         Show firmware information
    bands           Show current band configuration
    band-lock       Lock to specific bands
    band-unlock     Unlock all bands (automatic)
    ca-info         Show Carrier Aggregation status
    scan            Scan available bands (quick/medium/full)
    setup           Interactive setup wizard

OPTIONS:
    -h, --help      Show help message
    -v, --verbose   Verbose output
    -d, --device    Specify device path

EXAMPLES:
    $PROG_NAME fcc-status
    $PROG_NAME fcc-unlock
    $PROG_NAME fw-info
    $PROG_NAME bands
    $PROG_NAME band-lock --lte 3,7,20 --5g 78
    $PROG_NAME band-unlock
    $PROG_NAME ca-info
    $PROG_NAME scan quick
    $PROG_NAME scan medium
    $PROG_NAME scan full
EOF
}

log_info() { echo "[INFO] $1"; }
log_error() { echo "[ERROR] $1"; }
log_debug() {
    # M3 fix: Use VERBOSE flag for debug messages
    [ "$VERBOSE" = "1" ] && echo "[DEBUG] $1"
}

# M4 fix: Check for required command dependencies
check_dependencies() {
    local missing=""

    # Check all required commands
    for cmd in timeout stty printf cat tr grep cut awk; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing="$missing $cmd"
        fi
    done

    if [ -n "$missing" ]; then
        log_error "Missing required commands:$missing"
        log_error "Please install busybox or the missing utilities"
        return 1
    fi

    log_debug "Dependency check passed: all required commands found"
    return 0
}

get_device() {
    if [ -n "$DEVICE_OVERRIDE" ]; then
        echo "$DEVICE_OVERRIDE"
    else
        for dev in /dev/ttyUSB*; do
            if [ -c "$dev" ]; then
                # Properly communicate with device using stty and printf
                response=$(timeout 3 sh -c "
                    stty -F \"$dev\" raw -echo 115200 2>/dev/null || exit 1
                    printf 'ATI\r\n' > \"$dev\"
                    sleep 1
                    cat \"$dev\" 2>/dev/null
                " 2>/dev/null)
                if echo "$response" | grep -qi "fibocom\|fm350"; then
                    echo "$dev"
                    return
                fi
            fi
        done
        echo "$DEFAULT_DEVICE"
    fi
}

show_status() {
    local device=$(get_device)
    log_info "Checking modem status on $device..."

    if [ ! -c "$device" ]; then
        log_error "Device $device not found"
        return 1
    fi

    echo "=== Modem Status ==="
    echo "Device: $device"

    # Check if device responds
    response=$(timeout 5 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'ATI\r\n' > $device
        sleep 1
        cat $device 2>/dev/null
    " | tr -d '\r' | grep -v '^$' | head -5)

    if [ -n "$response" ]; then
        echo "Status: Connected"
        echo "$response"
    else
        echo "Status: No response"
        return 1
    fi
}

fcc_status() {
    local device=$(get_device)
    log_info "Checking FCC lock status on $device..."

    if [ ! -c "$device" ]; then
        log_error "Device $device not found"
        return 1
    fi

    echo "=== FCC Lock Status ==="

    # Check FCC lock status with AT+GTFCCLOCK?
    response=$(timeout 5 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'AT+GTFCCLOCK?\r\n' > $device
        sleep 1
        cat $device 2>/dev/null
    " | tr -d '\r' | grep -v '^$')

    if echo "$response" | grep -qi "GTFCCLOCK"; then
        echo "$response"
        if echo "$response" | grep -qi "0"; then
            echo "FCC Status: UNLOCKED"
            return 0
        else
            echo "FCC Status: LOCKED"
            return 1
        fi
    else
        log_error "Unable to determine FCC status"
        return 2
    fi
}

fcc_unlock() {
    local device=$(get_device)
    log_info "Starting FCC unlock procedure on $device..."

    if [ ! -c "$device" ]; then
        log_error "Device $device not found"
        return 1
    fi

    echo "=== FCC Unlock Procedure ==="

    # Send FCC unlock command
    echo "Sending unlock command..."
    response=$(timeout 10 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'AT+GTFCCLOCK=0\r\n' > $device
        sleep 2
        cat $device 2>/dev/null
    " | tr -d '\r' | grep -v '^$')

    echo "$response"

    if echo "$response" | grep -qi "OK"; then
        log_info "FCC unlock successful"
        echo "SUCCESS: FCC unlock completed"
        return 0
    else
        log_error "FCC unlock failed"
        echo "FAILED: FCC unlock unsuccessful"
        return 1
    fi
}

fw_info() {
    local device=$(get_device)
    log_info "Retrieving firmware information from $device..."

    if [ ! -c "$device" ]; then
        log_error "Device $device not found"
        return 1
    fi

    echo "=== Firmware Information ==="

    # Get firmware version
    response=$(timeout 5 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'AT+CGMR\r\n' > $device
        sleep 1
        cat $device 2>/dev/null
    " | tr -d '\r' | grep -v '^$' | grep -v 'AT+CGMR')

    if [ -n "$response" ]; then
        echo "Firmware Version:"
        echo "$response"
    else
        echo "Unable to retrieve firmware info"
        return 1
    fi

    # Get model info
    response=$(timeout 5 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'ATI\r\n' > $device
        sleep 1
        cat $device 2>/dev/null
    " | tr -d '\r' | grep -v '^$' | grep -v 'ATI')

    if [ -n "$response" ]; then
        echo ""
        echo "Model Information:"
        echo "$response"
    fi
}

show_bands() {
    local device=$(get_device)
    log_info "Retrieving band configuration from $device..."

    if [ ! -c "$device" ]; then
        log_error "Device $device not found"
        return 1
    fi

    echo "=== Current Band Configuration (Fibocom FM350-GL) ==="
    echo ""

    # Get LTE bands
    echo "LTE Bands:"
    response=$(timeout 5 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'AT+QNWPREFCFG=\"lte_band\"\r\n' > $device
        sleep 1
        cat $device 2>/dev/null
    " | tr -d '\r' | grep -v '^$' | grep QNWPREFCFG)

    if [ -n "$response" ]; then
        bands=$(echo "$response" | cut -d'"' -f4)
        if [ "$bands" = "0" ]; then
            echo "  Automatic (all bands)"
        else
            echo "  Locked to: B$bands" | sed 's/:/, B/g'
        fi
    else
        echo "  Unable to retrieve"
    fi

    echo ""

    # Get 5G SA bands
    echo "5G SA Bands:"
    response=$(timeout 5 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'AT+QNWPREFCFG=\"nr5g_band\"\r\n' > $device
        sleep 1
        cat $device 2>/dev/null
    " | tr -d '\r' | grep -v '^$' | grep QNWPREFCFG)

    if [ -n "$response" ]; then
        bands=$(echo "$response" | cut -d'"' -f4)
        if [ "$bands" = "0" ]; then
            echo "  Automatic (all bands)"
        else
            echo "  Locked to: n$bands" | sed 's/:/, n/g'
        fi
    else
        echo "  Unable to retrieve"
    fi

    echo ""

    # Get 5G NSA bands
    echo "5G NSA Bands:"
    response=$(timeout 5 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'AT+QNWPREFCFG=\"nsa_nr5g_band\"\r\n' > $device
        sleep 1
        cat $device 2>/dev/null
    " | tr -d '\r' | grep -v '^$' | grep QNWPREFCFG)

    if [ -n "$response" ]; then
        bands=$(echo "$response" | cut -d'"' -f4)
        if [ "$bands" = "0" ]; then
            echo "  Automatic (all bands)"
        else
            echo "  Locked to: n$bands" | sed 's/:/, n/g'
        fi
    else
        echo "  Unable to retrieve"
    fi

    echo ""

    # Get serving cell info
    echo "=== Current Active Band ==="
    response=$(timeout 5 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'AT+QENG=\"servingcell\"\r\n' > $device
        sleep 1
        cat $device 2>/dev/null
    " | tr -d '\r' | grep -v '^$' | grep -E "LTE|NR5G")

    if [ -n "$response" ]; then
        echo "$response"
    else
        echo "Unable to retrieve serving cell info"
    fi
}

band_lock() {
    local device=$(get_device)
    local lte_bands=""
    local nr5g_bands=""

    # Parse arguments
    while [ $# -gt 0 ]; do
        case $1 in
            --lte)
                lte_bands="$2"
                shift 2
                ;;
            --5g)
                nr5g_bands="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    if [ -z "$lte_bands" ] && [ -z "$nr5g_bands" ]; then
        echo "Usage: $PROG_NAME band-lock --lte <bands> --5g <bands>"
        echo "Example: $PROG_NAME band-lock --lte 3,7,20 --5g 78"
        return 1
    fi

    log_info "Applying band lock configuration to $device..."

    if [ ! -c "$device" ]; then
        log_error "Device $device not found"
        return 1
    fi

    # Lock LTE bands
    if [ -n "$lte_bands" ]; then
        log_info "Locking LTE bands to: $lte_bands"
        lte_formatted=$(echo "$lte_bands" | tr ',' ':')

        response=$(timeout 10 sh -c "
            stty -F $device raw -echo 115200 2>/dev/null
            printf 'AT+QNWPREFCFG=\"lte_band\",$lte_formatted\r\n' > $device
            sleep 2
            cat $device 2>/dev/null
        " | tr -d '\r' | grep -v '^$')

        if echo "$response" | grep -q "OK"; then
            log_info "LTE bands locked successfully"
        else
            log_error "Failed to lock LTE bands"
        fi
    fi

    # Lock 5G bands
    if [ -n "$nr5g_bands" ]; then
        log_info "Locking 5G bands to: $nr5g_bands"
        nr5g_formatted=$(echo "$nr5g_bands" | tr ',' ':')

        # Set SA bands
        response=$(timeout 10 sh -c "
            stty -F $device raw -echo 115200 2>/dev/null
            printf 'AT+QNWPREFCFG=\"nr5g_band\",$nr5g_formatted\r\n' > $device
            sleep 2
            cat $device 2>/dev/null
        " | tr -d '\r' | grep -v '^$')

        # Set NSA bands
        timeout 10 sh -c "
            stty -F $device raw -echo 115200 2>/dev/null
            printf 'AT+QNWPREFCFG=\"nsa_nr5g_band\",$nr5g_formatted\r\n' > $device
            sleep 2
            cat $device 2>/dev/null
        " >/dev/null 2>&1

        if echo "$response" | grep -q "OK"; then
            log_info "5G bands locked successfully"
        else
            log_error "Failed to lock 5G bands"
        fi
    fi

    echo ""
    echo "Band locking applied. Run '$PROG_NAME bands' to verify."
}

band_unlock() {
    local device=$(get_device)
    log_info "Unlocking all bands (automatic selection) on $device..."

    if [ ! -c "$device" ]; then
        log_error "Device $device not found"
        return 1
    fi

    # Unlock LTE
    response=$(timeout 10 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'AT+QNWPREFCFG=\"lte_band\",0\r\n' > $device
        sleep 2
        cat $device 2>/dev/null
    " | tr -d '\r' | grep -v '^$')

    # Unlock 5G SA
    timeout 10 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'AT+QNWPREFCFG=\"nr5g_band\",0\r\n' > $device
        sleep 2
        cat $device 2>/dev/null
    " >/dev/null 2>&1

    # Unlock 5G NSA
    timeout 10 sh -c "
        stty -F $device raw -echo 115200 2>/dev/null
        printf 'AT+QNWPREFCFG=\"nsa_nr5g_band\",0\r\n' > $device
        sleep 2
        cat $device 2>/dev/null
    " >/dev/null 2>&1

    if echo "$response" | grep -q "OK"; then
        log_info "All bands unlocked successfully (automatic selection)"
    else
        log_error "Failed to unlock bands"
        return 1
    fi
}

# Carrier Aggregation Info
ca_info() {
    local device=$(get_device)
    log_info "Retrieving Carrier Aggregation info from $device..."

    if [ ! -c "$device" ]; then
        log_error "Device $device not found"
        return 1
    fi

    echo "=== Carrier Aggregation Status ==="
    echo ""

    # Try AT+QCAINFO first (direct CA info)
    response=$(timeout 10 sh -c "
        stty -F \"$device\" raw -echo 115200 2>/dev/null || exit 1
        printf 'AT+QCAINFO\r\n' > \"$device\"
        sleep 2
        cat \"$device\" 2>/dev/null
    " | tr -d '\r' | grep -v '^$')
    local cmd_status=$?

    # Check for timeout or command failure
    if [ $cmd_status -eq 124 ]; then
        log_error "AT+QCAINFO command timed out"
    elif [ $cmd_status -ne 0 ]; then
        log_error "AT+QCAINFO command failed with status $cmd_status"
    fi

    if [ -n "$response" ] && echo "$response" | grep -q "QCAINFO"; then
        parse_qcainfo "$response"
        return 0
    fi

    # Fallback to AT+QENG="servingcell"
    response=$(timeout 10 sh -c "
        stty -F \"$device\" raw -echo 115200 2>/dev/null || exit 1
        printf 'AT+QENG=\"servingcell\"\r\n' > \"$device\"
        sleep 2
        cat \"$device\" 2>/dev/null
    " | tr -d '\r' | grep -v '^$')
    cmd_status=$?

    # Check for timeout or command failure
    if [ $cmd_status -eq 124 ]; then
        log_error "AT+QENG command timed out"
    elif [ $cmd_status -ne 0 ]; then
        log_error "AT+QENG command failed with status $cmd_status"
    fi

    if [ -n "$response" ] && echo "$response" | grep -q "QENG"; then
        parse_qeng_ca "$response"
        return 0
    else
        echo "Status: No CA information available"
        echo ""
        echo "Possible reasons:"
        echo "  - Not connected to LTE/5G network"
        echo "  - Carrier Aggregation not active"
        echo "  - Weak signal or single carrier only"
        echo "  - Command timeout or device communication error"
        return 1
    fi
}

# Parse QCAINFO response
parse_qcainfo() {
    local data="$1"
    local pcc_count=0
    local scc_count=0

    # Extract QCAINFO lines
    local qcainfo_lines=$(echo "$data" | grep "QCAINFO")

    # Check if we have any CA info
    if [ -z "$qcainfo_lines" ]; then
        echo ""
        echo "Status: No Carrier Aggregation (single carrier)"
        return 0
    fi

    # Use for loop instead of while to avoid subshell (POSIX compliant)
    # Save IFS and set to newline for proper line splitting
    local oldifs="$IFS"
    IFS='
'
    for line in $qcainfo_lines; do
        if echo "$line" | grep -q "PCC"; then
            pcc_count=$((pcc_count + 1))
            echo "Primary Component Carrier (PCC):"
            parse_ca_component "$line"
        elif echo "$line" | grep -qE "SCC[0-9]?"; then
            scc_count=$((scc_count + 1))
            echo ""
            echo "Secondary Component Carrier (SCC$scc_count):"
            parse_ca_component "$line"
        fi
    done
    IFS="$oldifs"

    # Calculate total carriers
    local total_carriers=$((pcc_count + scc_count))
    if [ $total_carriers -gt 1 ]; then
        echo ""
        echo "Status: ACTIVE (${total_carriers}CA)"
        echo "Technology: LTE-Advanced"
    elif [ $total_carriers -eq 1 ]; then
        echo ""
        echo "Status: No Carrier Aggregation (single carrier)"
    else
        echo ""
        echo "Status: Unable to determine CA status"
    fi
}

# Parse individual CA component
parse_ca_component() {
    local line="$1"
    # Format: +QCAINFO: "PCC",freq,"band_name",bw,earfcn,rsrp,rsrq,rssi,sinr

    local freq=$(echo "$line" | cut -d',' -f2 | tr -d ' ')
    local band=$(echo "$line" | cut -d',' -f3 | tr -d '"' | tr -d ' ')
    local bw=$(echo "$line" | cut -d',' -f4 | tr -d ' ')
    local rsrp=$(echo "$line" | cut -d',' -f6 | tr -d ' ')
    local rsrq=$(echo "$line" | cut -d',' -f7 | tr -d ' ')
    local sinr=$(echo "$line" | cut -d',' -f9 | tr -d ' ')

    # Validate and set defaults for empty fields
    [ -z "$band" ] && band="Unknown"
    [ -z "$freq" ] && freq=""
    [ -z "$bw" ] && bw=""
    [ -z "$rsrp" ] && rsrp=""
    [ -z "$rsrq" ] && rsrq=""
    [ -z "$sinr" ] && sinr=""

    # Display information (only show fields that have values)
    echo "  Band: $band"
    [ -n "$freq" ] && echo "  Frequency: $freq MHz"
    [ -n "$bw" ] && echo "  Bandwidth: $bw MHz"
    [ -n "$rsrp" ] && echo "  RSRP: $rsrp dBm"
    [ -n "$rsrq" ] && echo "  RSRQ: $rsrq dB"
    [ -n "$sinr" ] && echo "  SINR: $sinr dB"
}

# Parse QENG response for CA
parse_qeng_ca() {
    local data="$1"
    local pcc_line=$(echo "$data" | grep "QENG" | grep -E "LTE|NR5G" | grep -v "SCC" | head -1)
    local scc_lines=$(echo "$data" | grep "QENG" | grep "SCC")

    if [ -n "$pcc_line" ]; then
        echo "Primary Component Carrier (PCC):"
        parse_qeng_component "$pcc_line"
    fi

    if [ -n "$scc_lines" ]; then
        local scc_num=1

        # Use for loop to avoid subshell (POSIX compliant)
        local oldifs="$IFS"
        IFS='
'
        for line in $scc_lines; do
            echo ""
            echo "Secondary Component Carrier (SCC$scc_num):"
            parse_qeng_component "$line"
            scc_num=$((scc_num + 1))
        done
        IFS="$oldifs"

        local scc_count=$(echo "$scc_lines" | wc -l)
        local total=$((scc_count + 1))
        echo ""
        echo "Status: ACTIVE (${total}CA)"
        echo "Technology: LTE-Advanced"
        return 0
    else
        echo ""
        echo "Status: No Carrier Aggregation detected"
        return 0
    fi
}

# Parse QENG component
parse_qeng_component() {
    local line="$1"
    # Extract band and signal info from QENG servingcell
    local band=$(echo "$line" | awk -F',' '{for(i=1;i<=NF;i++) if($i ~ /^[0-9]+$/ && $i < 100) print $i}' | head -1)
    local rsrp=$(echo "$line" | awk -F',' '{print $(NF-3)}')
    local rsrq=$(echo "$line" | awk -F',' '{print $(NF-2)}')
    local sinr=$(echo "$line" | awk -F',' '{print $(NF)}')

    [ -n "$band" ] && echo "  Band: B$band"
    [ -n "$rsrp" ] && echo "  RSRP: $rsrp dBm"
    [ -n "$rsrq" ] && echo "  RSRQ: $rsrq dB"
    [ -n "$sinr" ] && echo "  SINR: $sinr dB"
}

# Band Scanning
band_scan() {
    local device=$(get_device)
    local scan_mode="${1:-quick}"

    log_info "Starting band scan ($scan_mode mode) on $device..."
    log_debug "VERBOSE mode enabled - showing detailed progress"

    if [ ! -c "$device" ]; then
        log_error "Device $device not found"
        return 1
    fi

    case "$scan_mode" in
        quick)
            scan_quick "$device"
            ;;
        medium)
            scan_medium "$device"
            ;;
        full)
            scan_full "$device"
            ;;
        *)
            echo "Unknown scan mode: $scan_mode"
            echo "Usage: $PROG_NAME scan [quick|medium|full]"
            echo ""
            echo "  quick  - Fast neighbour scan (5-10 seconds)"
            echo "  medium - Serving + neighbour cells (10-20 seconds)"
            echo "  full   - Complete network scan (1-3 minutes, disconnects modem!)"
            return 1
            ;;
    esac
}

# Quick scan - neighbour cells only
scan_quick() {
    local device="$1"

    echo "=== Quick Band Scan ==="
    echo "Scanning neighbour cells (5-10 seconds)..."
    echo ""

    response=$(timeout 15 sh -c "
        stty -F \"$device\" raw -echo 115200 2>/dev/null || exit 1
        printf 'AT+QENG=\"neighbourcell\"\r\n' > \"$device\"
        sleep 3
        cat \"$device\" 2>/dev/null
    " | tr -d '\r' | grep -v '^$' | grep "QENG")

    if [ -z "$response" ]; then
        echo "No neighbour cells detected"
        echo "Possible reasons:"
        echo "  - Weak signal area"
        echo "  - No other cells in range"
        echo "  - Modem not connected to network"
        return 1
    fi

    parse_neighbour_cells "$response"
}

# Medium scan - serving + neighbour
scan_medium() {
    local device="$1"

    echo "=== Medium Band Scan ==="
    echo "Scanning serving and neighbour cells..."
    echo ""

    # Get serving cell
    echo "Current Connection:"
    response=$(timeout 10 sh -c "
        stty -F \"$device\" raw -echo 115200 2>/dev/null || exit 1
        printf 'AT+QENG=\"servingcell\"\r\n' > \"$device\"
        sleep 2
        cat \"$device\" 2>/dev/null
    " | tr -d '\r' | grep -v '^$' | grep "QENG")

    if [ -n "$response" ]; then
        parse_serving_cell "$response"
    fi

    echo ""
    echo "Detected Bands in Area:"
    echo ""

    # Get neighbour cells
    response=$(timeout 15 sh -c "
        stty -F \"$device\" raw -echo 115200 2>/dev/null || exit 1
        printf 'AT+QENG=\"neighbourcell\"\r\n' > \"$device\"
        sleep 3
        cat \"$device\" 2>/dev/null
    " | tr -d '\r' | grep -v '^$' | grep "QENG")

    if [ -n "$response" ]; then
        parse_neighbour_cells "$response"
    else
        echo "No neighbour cells detected"
    fi
}

# Full scan - complete network scan
scan_full() {
    local device="$1"

    echo "=== Full Network Scan ==="
    echo "WARNING: This scan will disconnect your modem and may take up to 3 minutes!"

    # Check if we have interactive terminal (stdin is TTY)
    if [ -t 0 ]; then
        # Interactive mode - ask for confirmation
        echo -n "Continue? (y/N): "
        read -r confirm || {
            echo "Failed to read input"
            return 1
        }

        if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
            echo "Scan cancelled"
            return 0
        fi
    else
        # Non-interactive mode (LuCI, cron, etc.) - proceed automatically
        echo "Non-interactive mode detected - proceeding automatically"
        echo "Note: Ensure confirmation was obtained before calling this command"
    fi

    echo ""
    echo "Scanning all available networks (this will take 1-3 minutes)..."

    # Perform scan with dynamic timeout (exit when we get response)
    response=$(timeout 200 sh -c "
        stty -F \"$device\" raw -echo 115200 2>/dev/null || exit 1
        printf 'AT+COPS=?\r\n' > \"$device\"

        # Read response dynamically - exit when we get OK or ERROR (max 180s)
        result=\"\"
        max_wait=180
        elapsed=0
        while [ \$elapsed -lt \$max_wait ]; do
            # Read with 5 second timeout
            chunk=\$(timeout 5 dd if=\"$device\" bs=1 count=2048 2>/dev/null || true)
            result=\"\${result}\${chunk}\"

            # Check if we got complete response (contains OK or ERROR)
            if echo \"\$result\" | grep -q \"OK\\|ERROR\"; then
                break
            fi

            sleep 2
            elapsed=\$((elapsed + 7))
        done
        echo \"\$result\"
    " | tr -d '\r' | grep -v '^$')

    if echo "$response" | grep -q "COPS"; then
        echo ""
        echo "Available Networks:"
        echo ""
        parse_cops_response "$response"
    else
        echo "Network scan failed or timed out"
        return 1
    fi

    # Reconnect to automatic network
    echo ""
    echo "Reconnecting to network (automatic mode)..."
    timeout 30 sh -c "
        stty -F \"$device\" raw -echo 115200 2>/dev/null || exit 1
        printf 'AT+COPS=0\r\n' > \"$device\"
        sleep 10
        cat \"$device\" 2>/dev/null
    " >/dev/null 2>&1

    echo "Scan complete. Your modem should reconnect automatically."
}

# Parse neighbour cells
parse_neighbour_cells() {
    local data="$1"

    printf "%-6s | %-5s | %-8s | %-9s | %-8s | %s\n" "Band" "Type" "EARFCN" "RSRP" "RSRQ" "Quality"
    printf "%s\n" "-------|-------|----------|-----------|----------|----------"

    # Pre-filter lines to avoid grep in every iteration (M1 optimization)
    echo "$data" | grep "neighbourcell" | while IFS= read -r line; do
        local tech=$(echo "$line" | cut -d',' -f2 | tr -d '"')
        local earfcn=$(echo "$line" | cut -d',' -f3)
        local rsrp=$(echo "$line" | awk -F',' '{print $(NF-4)}')
        local rsrq=$(echo "$line" | awk -F',' '{print $(NF-3)}')

        # Convert EARFCN to band (simplified)
        local band=$(earfcn_to_band "$earfcn")

        # Determine quality
        local quality="Poor"
        if [ "$rsrp" -gt -90 ] 2>/dev/null; then
            quality="Excellent"
        elif [ "$rsrp" -gt -100 ] 2>/dev/null; then
            quality="Good"
        elif [ "$rsrp" -gt -110 ] 2>/dev/null; then
            quality="Fair"
        fi

        printf "%-6s | %-5s | %-8s | %-9s | %-8s | %s\n" \
            "$band" "$tech" "$earfcn" "${rsrp} dBm" "${rsrq} dB" "$quality"
    done
}

# Parse serving cell
parse_serving_cell() {
    local data="$1"
    local line=$(echo "$data" | grep "LTE\|NR5G" | grep -v "neighbour" | head -1)

    if [ -n "$line" ]; then
        local tech=$(echo "$line" | cut -d',' -f2 | tr -d '"')
        local band=$(echo "$line" | awk -F',' '{for(i=1;i<=NF;i++) if($i ~ /^[0-9]+$/ && $i < 100) print $i}' | head -1)
        local rsrp=$(echo "$line" | awk -F',' '{print $(NF-3)}')
        local rsrq=$(echo "$line" | awk -F',' '{print $(NF-2)}')

        echo "  Technology: $tech"
        [ -n "$band" ] && echo "  Band: B$band"
        [ -n "$rsrp" ] && echo "  RSRP: $rsrp dBm"
        [ -n "$rsrq" ] && echo "  RSRQ: $rsrq dB"
    fi
}

# Parse COPS response
parse_cops_response() {
    local data="$1"

    printf "%-15s | %-12s | %s\n" "Operator" "Status" "Technology"
    printf "%s\n" "----------------|--------------|-------------"

    echo "$data" | grep -o '([^)]*)' | while IFS= read -r entry; do
        local stat=$(echo "$entry" | cut -d',' -f1 | tr -d '(')
        local name=$(echo "$entry" | cut -d',' -f2 | tr -d '"')
        local act=$(echo "$entry" | cut -d',' -f5 | tr -d ')')

        local status="Unknown"
        case "$stat" in
            0) status="Unknown" ;;
            1) status="Available" ;;
            2) status="Current" ;;
            3) status="Forbidden" ;;
        esac

        local tech="Unknown"
        case "$act" in
            0) tech="2G (GSM)" ;;
            2) tech="3G (UMTS)" ;;
            7) tech="4G (LTE)" ;;
            12) tech="5G (NR)" ;;
        esac

        printf "%-15s | %-12s | %s\n" "$name" "$status" "$tech"
    done
}

# Convert EARFCN to band (simplified mapping)
earfcn_to_band() {
    local earfcn="$1"

    # Validate input is a number (POSIX compliant)
    case "$earfcn" in
        ''|*[!0-9]*)
            echo "B?"
            return 1
            ;;
    esac

    # Basic EARFCN to band mapping for common bands
    if [ "$earfcn" -ge 0 ] && [ "$earfcn" -le 599 ]; then
        echo "B1"
    elif [ "$earfcn" -ge 600 ] && [ "$earfcn" -le 1199 ]; then
        echo "B2"
    elif [ "$earfcn" -ge 1200 ] && [ "$earfcn" -le 1949 ]; then
        echo "B3"
    elif [ "$earfcn" -ge 1950 ] && [ "$earfcn" -le 2399 ]; then
        echo "B4"
    elif [ "$earfcn" -ge 2400 ] && [ "$earfcn" -le 2649 ]; then
        echo "B5"
    elif [ "$earfcn" -ge 2750 ] && [ "$earfcn" -le 3449 ]; then
        echo "B7"
    elif [ "$earfcn" -ge 3450 ] && [ "$earfcn" -le 3799 ]; then
        echo "B8"
    elif [ "$earfcn" -ge 5010 ] && [ "$earfcn" -le 5179 ]; then
        echo "B12"
    elif [ "$earfcn" -ge 5730 ] && [ "$earfcn" -le 5849 ]; then
        echo "B13"
    elif [ "$earfcn" -ge 6150 ] && [ "$earfcn" -le 6449 ]; then
        echo "B20"
    elif [ "$earfcn" -ge 9210 ] && [ "$earfcn" -le 9659 ]; then
        echo "B28"
    elif [ "$earfcn" -ge 66436 ] && [ "$earfcn" -le 67335 ]; then
        echo "B66"
    elif [ "$earfcn" -ge 68586 ] && [ "$earfcn" -le 68935 ]; then
        echo "B71"
    else
        echo "B?"
    fi
}

VERBOSE=0
DEVICE_OVERRIDE=""

# M4 fix: Check dependencies before proceeding
if ! check_dependencies; then
    exit 1
fi

while [ $# -gt 0 ]; do
    case $1 in
        -h|--help) usage; exit 0;;
        -v|--verbose) VERBOSE=1; shift;;
        -d|--device) DEVICE_OVERRIDE="$2"; shift 2;;
        status) show_status; exit 0;;
        fcc-status) fcc_status; exit 0;;
        fcc-unlock) fcc_unlock; exit 0;;
        fw-info) fw_info; exit 0;;
        bands) show_bands; exit 0;;
        band-lock) shift; band_lock "$@"; exit 0;;
        band-unlock) band_unlock; exit 0;;
        ca-info) ca_info; exit 0;;
        scan) shift; band_scan "$@"; exit 0;;
        setup) echo "Interactive setup not implemented"; exit 0;;
        *) echo "Unknown command: $1"; usage; exit 1;;
    esac
    shift
 done

usage
